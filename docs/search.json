[
  {
    "objectID": "info_pysmd.html",
    "href": "info_pysmd.html",
    "title": "SMD (.HDF5) data format",
    "section": "",
    "text": "We say that data from a single-molecule experiment is stored in an SMD. These exist in files (HDF5 format) or in memory as an object. This format is slighty different than originally described in: Greenfeld, M., van de Meent, JW., Pavlichin, D.S. et al. Single-molecule dataset (SMD): a generalized storage format for raw and processed single-molecule data. BMC Bioinformatics 16, 3 (2015). https://doi.org/10.1186/s12859-014-0429-4.\n\n\n\nHDF5 file based instead of JSON\nMultiple SMDs can live in the same HDF5 file; each lives as a group within the HDF5 file\nFlexible WRT analysis: results from any analysis should be saved as a sub-group within the particular SMD.\nWhen molecules from different data sources can be combined into the same SMD, the original source is remembered.\nClassifying/grouping molecules is very important for many methods; each molecule in the SMD has an integer to specify the class to which it belongs.\n\n\n\n\nInstall in place using\ncd <path to pysmd-hdf5 folder>\npip install -e './'\n\n\n\nNotes/Non-standard points are put in angle brackets.\n\n\nAssume you have an SMD container object called dataset\ndataset.raw : ndarray(NxTxD...) - the data\n<!-- dataset.classes : ndarray(N) - integers of class to which each molecule is assigned -->\n<!-- dataset.data_index : ndarray(N) - integers specifying current order of molecules in the SMD -->\ndataset.source_index : ndarray(N) - integers specifying the source each molecule came from\ndataset.source_names : list - the names of each sources\ndataset.source_dicts : list - dictionaries with metadata entries for each source\ndataset.smd_dict : dictionary - metadata entries describing smd file\n\ndataset.nmol : int - the value of dataset.raw.shape[0]\ndataset.nt : int - the value of dataset.raw.shape[1]\ndataset.ntime : int - the value of dataset.raw.shape[1]\ndataset.ncolor : int - the value of dataset.raw.shape[2]\ndataset.ncolors : int - the value of dataset.raw.shape[2]\ndataset.ndata - : int - the value of dataset.raw.shape[2:]\n\n\n\nAssume you have an HDF5 file with handle f that contains an SMD2 entry called ‘my_smd_expt7’.\nf['my_smd_expt7'] : group - this is the SMD2 entry\nf['my_smd_expt7'].attrs['format'] = \"SMD\"\nf['my_smd_expt7'].attrs['date_created'] = <time.ctime() upon creation>\nf['my_smd_expt7'].attrs['date_modified'] = <time.ctime() upon last save>\nf['my_smd_expt7'].attrs['description'] = \"Description of the dataset goes here\"\n\nf['my_smd_expt7/data'] : group - this holds the data\nf['my_smd_expt7/data/raw'] : dataset[int/float/double (nmol,ntime,ndata)] - this is the data for each molecule\n<!-- f['my_smd_expt7/data/classes'] : dataset[int (nmol)] - specifies the class for each molecule -->\nf['my_smd_expt7/data/source_index'] : dataset[int (nmol)] - specifies the source for each molecule\n\nf['my_smd_expt7/sources'] : group - This holds the information about the origin of each molecule (e.g., separate movies)\nf['my_smd_expt7/sources/0'] : group - Information about source 0 in the source_index list\nf['my_smd_expt7/sources/0'] : group - Information about the Nth source in the source_index list\nf['my_smd_expt7/sources/0'].attrs['source_name'] = \"<Description of this source, e.g. movie 12\">\nf['my_smd_expt7/sources/0'].attrs['<Name for a bit of metadata for this source>'] = \"<the metadata itself>\"\nf['my_smd_expt7/sources/0'].attrs['<Name for another bit of metadata for this source>'] = \"<the metadata itself>\"\n...... more metadata for source 0\nf['my_smd_expt7/sources/1'] : group - information about source 1 in the source_index list\n.... entries for source 1\n.. more sources\n\nf['my_smd_expt7/analysisA'] : group  - this is an example of how you would save an analysis (i.e., within this hdf5 group)\nf['my_smd_expt7/program7result'] : group - each program is responsible for the format/specification beyond this point...\n\n\n\n\n\nWhat do you do if you want to combine different types of data into the same dataset (e.g., movie punchouts and XY coordinates)? Use two separate SMDs, since the data is distinct. You can use the decription to reference the different entries"
  },
  {
    "objectID": "info_priors.html",
    "href": "info_priors.html",
    "title": "Information on priors",
    "section": "",
    "text": "Here’s some info on priors"
  },
  {
    "objectID": "index.html",
    "href": "index.html",
    "title": "Welcome to tMAVEN",
    "section": "",
    "text": "Learn how use the tMAVEN modeling, analysis, and visualization environment"
  },
  {
    "objectID": "install.html",
    "href": "install.html",
    "title": "Installing tMAVEN",
    "section": "",
    "text": "New Python Environment\nConsider making a separate conda enviroment for tMAVEN\n\n\nInstall package\n\nDownload from github\nrun:\n\npip install\n\nrun\n\ntmaven"
  },
  {
    "objectID": "about.html",
    "href": "about.html",
    "title": "About tMAVEN",
    "section": "",
    "text": "Intro\ntMAVEN is a development that came out of the Gonzalez Biophysics Lab from the Gonzalez lab at Columbia University from ~2015-now"
  },
  {
    "objectID": "extra_hmms.html",
    "href": "extra_hmms.html",
    "title": "Two-state HMMs",
    "section": "",
    "text": "Two-state Markov chain\nConsider this two-state Markov chain\n\n\n\n\n\n\n\nD\n\n  \n\n0\n\n 0   \n\n0->0\n\n  P_00   \n\n1\n\n 1   \n\n0->1\n\n  P_01   \n\n1->0\n\n  P_10   \n\n1->1\n\n  P_11  \n\n\n\n\n\nHere, the only two parameters are \\(P_{01}\\) and \\(P_{10}\\), where \\(P_{ij}\\) is the transition from state \\(i\\) to \\(j\\). The self transitions for states 0 and 1 are \\(P_{00}=P_{01}\\) and \\(P_{11}=1-P_{10}\\). Also the steady state probabilities for states 0 and 1 are \\(P^{ss}_0 = \\frac{P_{10}}{P_{01}+P_{10}}\\) and \\(P^{ss}_1 = \\frac{P_{01}}{P_{01}+P_{10}}\\), respectively (we’ll show this below if you don’t believe).\nThe transition matrix, \\(\\mathcal{A}\\) is then: \\[ \\mathcal{A} = \\begin{bmatrix}P_{00} & P_{01}\\\\P_{10} & P_{11}\\end{bmatrix},\\] where you begin in row \\(i\\) and end up in column \\(j\\) for each transition.\n\n\nTransitions\nBeginning in a particular state \\(P^{t=0} = \\begin{bmatrix} P^{t=0}_0 \\\\ P^{t=0}_1 \\end{bmatrix}\\), the probability after one time step is then \\(P^{t=1} = \\mathcal{A}^T P^{t=0}\\), where \\(T\\) is the transpose. After two time steps it is \\(P^{t=2} = \\mathcal{A}^T\\mathcal{A}^T P^{t=0} = \\left(\\mathcal{A}^T\\right)^2 P^{t=0}\\), etc.\n\n\nEigenvalues and Eigenvectors of \\(\\mathcal{A}\\)\nTo find the eigenvalues of \\(\\mathcal{A}\\), solve the eigenvalue equation $ v=v (-)v = 0 $. The equation has solutions only if \\(\\vert (\\mathcal{A}-\\mathcal{I}\\lambda)v \\vert = 0\\). Which is that\n\\[ \\lvert \\begin{bmatrix}P_{00}-\\lambda & P_{01}\\\\P_{10} & P_{11}-\\lambda\\end{bmatrix}\\rvert = ( P_{00}-\\lambda )( P_{00}-\\lambda ) - P_{01}P_{10} = 0\\]\nUse the quadratic formula to solve for the two eigenvectors \\(\\lambda_+ = 1\\) and \\(\\lambda_- = 1-P_{01}-P_{10}\\). Plug each eigenvector back in to the eigenvalue equation and solve to get the following relationships between \\(v_0\\) and \\(v_1\\) from \\(v=\\begin{bmatrix} v_0 \\\\ v_1 \\end{bmatrix}\\): \\(v_{1+} = \\frac{P_{01}}{P_{10}}v_{0+}\\) and \\(v_{0-} = - v_{1-}\\).\nTo obtain eigenvectors from these constraints impose an additional constraint that the mangnitude of an eigenvector must be 1 (i.e., \\(\\vert v \\vert = 1\\)). Since \\(\\vert v \\vert = \\sqrt(v_0^2+v_1^2)\\), this yields that the eigenvectors for \\(\\mathcal{A}\\) are \\(v_+ = \\begin{bmatrix} \\frac{P_{10}}{\\sqrt{P_{01}^2 + P_{10}^2}} \\\\ \\frac{P_{01}}{\\sqrt{P_{01}^2 + P_{10}^2}} \\end{bmatrix}\\) and \\(v_-\\begin{bmatrix} \\frac{-1}{\\sqrt{2}} \\\\ \\frac{1}{\\sqrt{2}} \\end{bmatrix}\\).\n\n\nPropagation of an arbitrary number of steps\nTo propagate the system an arbitrary number of steps, \\(k\\), we need to calculate \\(\\left(\\mathcal{A}^T\\right)^k P^{0}\\), however the exponential is tricky. To do this, make use the the identity \\(\\mathcal{A}^k = \\mathcal{P}\\mathcal{D}^k\\mathcal{P}^{-1}\\), where \\(\\mathcal{P} = \\begin{bmatrix} v_{0+} & v_{0-} \\\\ v_{1+} & v_{1-} \\end{bmatrix}\\) and \\(\\mathcal{D}^k = \\begin{bmatrix} \\lambda_+^k & 0 \\\\ 0 & \\lambda_-^k\\end{bmatrix}\\)\nDoing this matrix multiplication out by hand, we find that \\[ P^{t=k} = \\mathcal{A}^k P^{t=0} = \\begin{bmatrix} P_0^{ss} + (P_0^{t=0}-P_0^{ss})(1-P_{01}-P_{10})^k \\\\ P_1^{ss} + (P_1^{t=0}-P_1^{ss})(1-P_{01}-P_{10})^k \\end{bmatrix} \\]\n\n\nAutocorrelation function\nThe un-normalized autocorrelation (ACF) for an HMM with signal value \\(y(t)\\) is \\(ACF(k) = \\mathbb{E}[(y(0)-\\langle y \\rangle )( y(k)-\\langle y \\rangle]\\), which is\n\\[ ACF(k) = \\sum_i \\left( \\sum_j (\\mu_i - \\langle \\mu \\rangle)(\\mu_j - \\langle \\mu \\rangle) \\left( \\left(\\mathcal{A}^T\\right)^k \\delta_i \\right)_j \\right) P_i^{ss} \\] where \\(\\delta_i\\) is a vector with one in the \\(i^{th}\\) position and zero everywhere else, and \\(\\langle \\mu \\rangle = \\sum_i \\mu_i P_i^{ss}\\).\nFor this two-state system, if \\(\\mu_0 = 0\\) and \\(\\mu_1 = 1\\), then this reduces to \\[ACF(k) = P_0^{ss}P_1^{ss}(P_0^{ss}+P_1^{ss})^2(1-P_{01}-P_{10})^k\\] and the normalized version is \\[G(k) = \\frac{ACF(k)}{ACF(0)} = (1-P_{01}-P_{10})^k\\]"
  },
  {
    "objectID": "examples/example_script1.html",
    "href": "examples/example_script1.html",
    "title": "Scripted modeling - no GUI",
    "section": "",
    "text": "Process some data with a kinetic model and then plot it all without using the GUI\nfrom tmaven.app import setup_maven\n\n#### Analyze some data\n## Make a new MAVEN instance\nmaven  = setup_maven(['--log_stdout'])\n\n## Load data\nmaven.io.load_smdtmaven_hdf5('./notes/example_smd.hdf5','L1-tRNA')\n\n## Turn on only the first 10 trajectorys\nmaven.data.flag_ons*=False\nmaven.data.flag_ons[:10]+=True\n\n## Run vbFRET model selection with 1 through 6 states\nmaven.modeler.run_fret_vbhmm_modelselection(1,6)\n\n\n\n#### Make some plots\nimport matplotlib.pyplot as plt\nfig,ax =plt.subplots(2)\n\n## Plot a 1D histogram in the first plots using the raw data instead of the Viterbi data\nmaven.plots.fret_hist1d.prefs['idealized'] = False\nmaven.plots.fret_hist1d.plot(fig,ax[0])\n\n## Plot a trajectory in the second plot\nax[1].plot(maven.data.corrected[0,:,0],'g')\nax[1].plot(maven.data.corrected[0,:,1],'r')\n\nplt.show()"
  },
  {
    "objectID": "examples/example_smdload.html",
    "href": "examples/example_smdload.html",
    "title": "Load SMD",
    "section": "",
    "text": "Here’s a code example\nmaven.io.load_smdtmaven_hdf5('./docs/examples/example_smd.hdf5','L1-tRNA')"
  },
  {
    "objectID": "develop.html",
    "href": "develop.html",
    "title": "Develop",
    "section": "",
    "text": "Make a new virtual environment and activate it, then setup\ngit clone [tmaven URL here]\ncd tMAVEN\npython -m venv env --clear\nWhen you are ready to develop,\nsource env/bin/activate\nIf you want to install,\npip install -e ./ --use-feature=2020-resolver\nthen you can run the app with\ntmaven"
  },
  {
    "objectID": "develop.html#the-.maven",
    "href": "develop.html#the-.maven",
    "title": "Develop",
    "section": "The .maven",
    "text": "The .maven\nThe class for the .maven lives in /tmaven/maven.py, and many of the objects within .maven that hold different functionalities are located in the files in /tmaven/controllers.\nWhenever you modify anything (specifically data) in .maven, you will probably want to tell the .gui, but technically the .maven doesn’t know about the .gui. The solution is to execute the .maven.emit_data_update() function after any such operation. By default, that function does nothing. However, when a .gui is hooked up to a .maven, the .gui overrides this function with one of its own. This is all automatically handled by the .gui, so all you have to do is call the .maven fxn where your update is complete.\n\n.maven.prefs\nThis is basically a special python dictionary. The big difference is that it maintains the original type of the value for each key. All .maven functions with any user adjustable options should be stored in here.\n\n\n.maven.io\nThis handles all of the loading, saving functions that ultimately go into .maven.smd and .maven.data\n\n\n.maven.smd\nThis object holds all of the ‘raw’ smd format data loaded into .maven. The .maven can only hold one of these. The format is explained a little more in /tmaven/pysmd/readme.md. Largely, after loading data into the smd, you shouldn’t be touching it. Instead you should be using things in .maven.data.\n\n\n.maven.data\nThis object has a maven.data.corrected, which is the main source of data you will be interacting with; it is reset to the .maven.smd.raw. Also, .classes lives in here, and .flag_ons is bool for whether a molecule should be included in an analysis step or not (accessed via .maven.selection.get_toggled_mask)\n\n\n.maven.corrections\nMostly just some helper functions\n\n\n.maven.cull\nMostly just some helper functions\n\n\n.maven.modeler\nThis object holds/manages all the models of the data. It also provides the functionality to make new models and holds onto cached versions of numba JITd functions for later.\nFunctions with the prefix cached_ are generally just models, with no interaction with the .maven. They are called by functions prefixed with run_, which might, for instance, gather the proper traces and collect the EFRET values to model.\nModels are stored in a model_container. These are largely undefined, but have a few requirements to make it worthwhile to switch between them. Basically, they’ll have a .type (identifying string to distinguish the type of model), and them an .idealize function that will be able to idealize the data in .maven.data.corrected. [wait, is this broken?]\n\n\n.maven.scripts\nExecute python scripts. You have a local variable called maven which is the .maven object, so you can operate on anything there.\n\n\n.maven.selection\nMostly just some helper functions. Also, .maven.selection.get_toggled_mask is useful.\n\n\n.maven.trace_filter\nSort of like a stand-alone program that operates by itself\n\n\n.maven.photobleaching\nSort of like a stand-alone program that operates by itself\n\n\n.maven.plots\nThis holds the analysis plots that live in /tmaven/controllers/analysis_plots. These functions take a mpl figure and axis, and work on them to plot the data."
  },
  {
    "objectID": "develop.html#the-.gui",
    "href": "develop.html#the-.gui",
    "title": "Develop",
    "section": "The .gui",
    "text": "The .gui\nThe .gui object is located in /tmaven/interface/main_window.py. It contains maybe objects that hold different things (to keep them organized), that are also found in the /tmaven/interface folder. Generally, the files with a ui_ prefix contain wrapping functions over their .maven counterparts, while the viewer_ prefix files contain unique functionality. For instance, the molecule table in /tmaven/interface/viewer_molecules.py allows you to see a lot of the information in the .maven.data object in a table form, but it’s not operating any (read: much) .maven functionality. Simiarily, the preference viewer in /tmaven/interface/viewer_prefs.py allows you to see the preferences in .maven.prefs (and allows you to change them …). These are in contrast to, say, the functions in ui_cull, which mostly just gather and execute the functions in .maven.cull.\n.gui has access to .maven, because it stores a pointer in .gui.maven\nIt automatically remembers you last mode (ND or smFRET), window size and location, and light or dark mode.\nThere is a trick played to speed up scrolling (using a timer). If you want to change the trace (.gui.index) using the .gui.change_index function to play nice with this trick.\n\n.gui.plot_container\n.gui.plot_container.plot is the mpl canvas for the trace plot the .gui.plot_container controls which canvas is shown (e.g., ND or smFRET) swapping modes in the menu_view also changes some preferences\n\n\n.gui.index\ndenotes the current trace displayed/acted upon\n\n\nmolecule table (command/ctrl + T)\nyou can select things and then use some of the menu items to change things about those traces. the selection menu items will change the selection on this table. For instance, you can select all, and then change the class of the selected.\n\n\npreferences (command/ctrl + P)\nsearch box at the top to narrow it down double click the second column to edit the preference value. After doing so, the .maven should emit a .maven.prefs.emit_changed signal that tells the .gui to update stuff like the plots. This is done automatically and you probably don’t need to worry about it.\n\n\ngui keys\n\n[: descrease post point by one\n]: increase post point by one\nr: reset photobleach of this trace\ng: toggle grid\np: auto photobleach this trace (when sum drops to zero)\nright arrow/down arrow: increase .gui.index\nleft arrow/up arrow: decrease .gui.index\nnumber keys: assigns class to .gui.index trace"
  },
  {
    "objectID": "develop.html#publish-changes.",
    "href": "develop.html#publish-changes.",
    "title": "Develop",
    "section": "Publish changes.",
    "text": "Publish changes.\n\nMake your changes. Use the quarto preview to make sure they’re good.\nRender the site using quarto render docs_src.\nUse git to add and commit the changes (including the .html files etc that get generated in the docs folder\ngithub actions will update and deploy the site in about one minute"
  }
]