[
  {
    "objectID": "info_priors.html",
    "href": "info_priors.html",
    "title": "Information on priors",
    "section": "",
    "text": "Here’s some info on priors"
  },
  {
    "objectID": "index.html",
    "href": "index.html",
    "title": "Welcome to tMAVEN",
    "section": "",
    "text": "Here is some documentation cookbook examples about how to use tMAVEN."
  },
  {
    "objectID": "install.html",
    "href": "install.html",
    "title": "Installing tMAVEN",
    "section": "",
    "text": "New Python Environment\nconda stuff\n\n\nInstall package\npip install -e ./"
  },
  {
    "objectID": "about.html",
    "href": "about.html",
    "title": "About tMAVEN",
    "section": "",
    "text": "Intro\ntMAVEN is a development that came out of the Gonzalez Biophysics Lab from the Gonzalez lab at Columbia University from ~2015-now"
  },
  {
    "objectID": "extra_hmms.html",
    "href": "extra_hmms.html",
    "title": "Two-state HMMs",
    "section": "",
    "text": "Two-state Markov chain\nConsider this two-state Markov chain\n\n\n\n\n\n\n\nD\n\n  \n\n0\n\n 0   \n\n0->0\n\n  P_00   \n\n1\n\n 1   \n\n0->1\n\n  P_01   \n\n1->0\n\n  P_10   \n\n1->1\n\n  P_11  \n\n\n\n\n\nHere, the only two parameters are \\(P_{01}\\) and \\(P_{10}\\), where \\(P_{ij}\\) is the transition from state \\(i\\) to \\(j\\). The self transitions for states 0 and 1 are \\(P_{00}=P_{01}\\) and \\(P_{11}=1-P_{10}\\). Also the steady state probabilities for states 0 and 1 are \\(P^{ss}_0 = \\frac{P_{10}}{P_{01}+P_{10}}\\) and \\(P^{ss}_1 = \\frac{P_{01}}{P_{01}+P_{10}}\\), respectively (we’ll show this below if you don’t believe).\nThe transition matrix, \\(\\mathcal{A}\\) is then: \\[ \\mathcal{A} = \\begin{bmatrix}P_{00} & P_{01}\\\\P_{10} & P_{11}\\end{bmatrix},\\] where you begin in row \\(i\\) and end up in column \\(j\\) for each transition.\n\n\nTransitions\nBeginning in a particular state \\(P^{t=0} = \\begin{bmatrix} P^{t=0}_0 \\\\ P^{t=0}_1 \\end{bmatrix}\\), the probability after one time step is then \\(P^{t=1} = \\mathcal{A}^T P^{t=0}\\), where \\(T\\) is the transpose. After two time steps it is \\(P^{t=2} = \\mathcal{A}^T\\mathcal{A}^T P^{t=0} = \\left(\\mathcal{A}^T\\right)^2 P^{t=0}\\), etc.\n\n\nEigenvalues and Eigenvectors of \\(\\mathcal{A}\\)\nTo find the eigenvalues of \\(\\mathcal{A}\\), solve the eigenvalue equation $ v=v (-)v = 0 $. The equation has solutions only if \\(\\vert (\\mathcal{A}-\\mathcal{I}\\lambda)v \\vert = 0\\). Which is that\n\\[ \\lvert \\begin{bmatrix}P_{00}-\\lambda & P_{01}\\\\P_{10} & P_{11}-\\lambda\\end{bmatrix}\\rvert = ( P_{00}-\\lambda )( P_{00}-\\lambda ) - P_{01}P_{10} = 0\\]\nUse the quadratic formula to solve for the two eigenvectors \\(\\lambda_+ = 1\\) and \\(\\lambda_- = 1-P_{01}-P_{10}\\). Plug each eigenvector back in to the eigenvalue equation and solve to get the following relationships between \\(v_0\\) and \\(v_1\\) from \\(v=\\begin{bmatrix} v_0 \\\\ v_1 \\end{bmatrix}\\): \\(v_{1+} = \\frac{P_{01}}{P_{10}}v_{0+}\\) and \\(v_{0-} = - v_{1-}\\).\nTo obtain eigenvectors from these constraints impose an additional constraint that the mangnitude of an eigenvector must be 1 (i.e., \\(\\vert v \\vert = 1\\)). Since \\(\\vert v \\vert = \\sqrt(v_0^2+v_1^2)\\), this yields that the eigenvectors for \\(\\mathcal{A}\\) are \\(v_+ = \\begin{bmatrix} \\frac{P_{10}}{\\sqrt{P_{01}^2 + P_{10}^2}} \\\\ \\frac{P_{01}}{\\sqrt{P_{01}^2 + P_{10}^2}} \\end{bmatrix}\\) and \\(v_-\\begin{bmatrix} \\frac{-1}{\\sqrt{2}} \\\\ \\frac{1}{\\sqrt{2}} \\end{bmatrix}\\).\n\n\nPropagation of an arbitrary number of steps\nTo propagate the system an arbitrary number of steps, \\(k\\), we need to calculate \\(\\left(\\mathcal{A}^T\\right)^k P^{0}\\), however the exponential is tricky. To do this, make use the the identity \\(\\mathcal{A}^k = \\mathcal{P}\\mathcal{D}^k\\mathcal{P}^{-1}\\), where \\(\\mathcal{P} = \\begin{bmatrix} v_{0+} & v_{0-} \\\\ v_{1+} & v_{1-} \\end{bmatrix}\\) and \\(\\mathcal{D}^k = \\begin{bmatrix} \\lambda_+^k & 0 \\\\ 0 & \\lambda_-^k\\end{bmatrix}\\)\nDoing this matrix multiplication out by hand, we find that \\[ P^{t=k} = \\mathcal{A}^k P^{t=0} = \\begin{bmatrix} P_0^{ss} + (P_0^{t=0}-P_0^{ss})(1-P_{01}-P_{10})^k \\\\ P_1^{ss} + (P_1^{t=0}-P_1^{ss})(1-P_{01}-P_{10})^k \\end{bmatrix} \\]\n\n\nAutocorrelation function\nThe un-normalized autocorrelation (ACF) for an HMM with signal value \\(y(t)\\) is \\(ACF(k) = \\mathbb{E}[(y(0)-\\langle y \\rangle )( y(k)-\\langle y \\rangle]\\), which is\n\\[ ACF(k) = \\sum_i \\left( \\sum_j (\\mu_i - \\langle \\mu \\rangle)(\\mu_j - \\langle \\mu \\rangle) \\left( \\left(\\mathcal{A}^T\\right)^k \\delta_i \\right)_j \\right) P_i^{ss} \\] where \\(\\delta_i\\) is a vector with one in the \\(i^{th}\\) position and zero everywhere else, and \\(\\langle \\mu \\rangle = \\sum_i \\mu_i P_i^{ss}\\).\nFor this two-state system, if \\(\\mu_0 = 0\\) and \\(\\mu_1 = 1\\), then this reduces to \\[ACF(k) = P_0^{ss}P_1^{ss}(P_0^{ss}+P_1^{ss})^2(1-P_{01}-P_{10})^k\\] and the normalized version is \\[G(k) = \\frac{ACF(k)}{ACF(0)} = (1-P_{01}-P_{10})^k\\]"
  },
  {
    "objectID": "examples/example_smdload.html",
    "href": "examples/example_smdload.html",
    "title": "Example: load SMD",
    "section": "",
    "text": "Here’s a code example\nmaven.io.load_smdtmaven_hdf5('./docs/examples/example_smd.hdf5','L1-tRNA')"
  },
  {
    "objectID": "info_molecule.html",
    "href": "info_molecule.html",
    "title": "Information 1",
    "section": "",
    "text": "Here is some documentation/cookbook examples about how to"
  },
  {
    "objectID": "develop.html",
    "href": "develop.html",
    "title": "Develop",
    "section": "",
    "text": "Make a new virtual environment and activate it, then setup\ngit clone [tmaven URL here]\ncd tMAVEN\npython -m venv env --clear\nWhen you are ready to develop,\nsource env/bin/activate\nIf you want to install,\npip install -e ./ --use-feature=2020-resolver\nthen you can run the app with\ntmaven"
  },
  {
    "objectID": "develop.html#the-.maven",
    "href": "develop.html#the-.maven",
    "title": "Develop",
    "section": "The .maven",
    "text": "The .maven\nThe class for the .maven lives in /tmaven/maven.py, and many of the objects within .maven that hold different functionalities are located in the files in /tmaven/controllers.\nWhenever you modify anything (specifically data) in .maven, you will probably want to tell the .gui, but technically the .maven doesn’t know about the .gui. The solution is to execute the .maven.emit_data_update() function after any such operation. By default, that function does nothing. However, when a .gui is hooked up to a .maven, the .gui overrides this function with one of its own. This is all automatically handled by the .gui, so all you have to do is call the .maven fxn where your update is complete.\n\n.maven.prefs\nThis is basically a special python dictionary. The big difference is that it maintains the original type of the value for each key. All .maven functions with any user adjustable options should be stored in here.\n\n\n.maven.io\nThis handles all of the loading, saving functions that ultimately go into .maven.smd and .maven.data\n\n\n.maven.smd\nThis object holds all of the ‘raw’ smd format data loaded into .maven. The .maven can only hold one of these. The format is explained a little more in /tmaven/pysmd/readme.md. Largely, after loading data into the smd, you shouldn’t be touching it. Instead you should be using things in .maven.data.\n\n\n.maven.data\nThis object has a maven.data.corrected, which is the main source of data you will be interacting with; it is reset to the .maven.smd.raw. Also, .classes lives in here, and .flag_ons is bool for whether a molecule should be included in an analysis step or not (accessed via .maven.selection.get_toggled_mask)\n\n\n.maven.corrections\nMostly just some helper functions\n\n\n.maven.cull\nMostly just some helper functions\n\n\n.maven.modeler\nThis object holds/manages all the models of the data. It also provides the functionality to make new models and holds onto cached versions of numba JITd functions for later.\nFunctions with the prefix cached_ are generally just models, with no interaction with the .maven. They are called by functions prefixed with run_, which might, for instance, gather the proper traces and collect the EFRET values to model.\nModels are stored in a model_container. These are largely undefined, but have a few requirements to make it worthwhile to switch between them. Basically, they’ll have a .type (identifying string to distinguish the type of model), and them an .idealize function that will be able to idealize the data in .maven.data.corrected. [wait, is this broken?]\n\n\n.maven.scripts\nExecute python scripts. You have a local variable called maven which is the .maven object, so you can operate on anything there.\n\n\n.maven.selection\nMostly just some helper functions. Also, .maven.selection.get_toggled_mask is useful.\n\n\n.maven.trace_filter\nSort of like a stand-alone program that operates by itself\n\n\n.maven.photobleaching\nSort of like a stand-alone program that operates by itself\n\n\n.maven.plots\nThis holds the analysis plots that live in /tmaven/controllers/analysis_plots. These functions take a mpl figure and axis, and work on them to plot the data."
  },
  {
    "objectID": "develop.html#the-.gui",
    "href": "develop.html#the-.gui",
    "title": "Develop",
    "section": "The .gui",
    "text": "The .gui\nThe .gui object is located in /tmaven/interface/main_window.py. It contains maybe objects that hold different things (to keep them organized), that are also found in the /tmaven/interface folder. Generally, the files with a ui_ prefix contain wrapping functions over their .maven counterparts, while the viewer_ prefix files contain unique functionality. For instance, the molecule table in /tmaven/interface/viewer_molecules.py allows you to see a lot of the information in the .maven.data object in a table form, but it’s not operating any (read: much) .maven functionality. Simiarily, the preference viewer in /tmaven/interface/viewer_prefs.py allows you to see the preferences in .maven.prefs (and allows you to change them …). These are in contrast to, say, the functions in ui_cull, which mostly just gather and execute the functions in .maven.cull.\n.gui has access to .maven, because it stores a pointer in .gui.maven\nIt automatically remembers you last mode (ND or smFRET), window size and location, and light or dark mode.\nThere is a trick played to speed up scrolling (using a timer). If you want to change the trace (.gui.index) using the .gui.change_index function to play nice with this trick.\n\n.gui.plot_container\n.gui.plot_container.plot is the mpl canvas for the trace plot the .gui.plot_container controls which canvas is shown (e.g., ND or smFRET) swapping modes in the menu_view also changes some preferences\n\n\n.gui.index\ndenotes the current trace displayed/acted upon\n\n\nmolecule table (command/ctrl + T)\nyou can select things and then use some of the menu items to change things about those traces. the selection menu items will change the selection on this table. For instance, you can select all, and then change the class of the selected.\n\n\npreferences (command/ctrl + P)\nsearch box at the top to narrow it down double click the second column to edit the preference value. After doing so, the .maven should emit a .maven.prefs.emit_changed signal that tells the .gui to update stuff like the plots. This is done automatically and you probably don’t need to worry about it.\n\n\ngui keys\n\n[: descrease post point by one\n]: increase post point by one\nr: reset photobleach of this trace\ng: toggle grid\np: auto photobleach this trace (when sum drops to zero)\nright arrow/down arrow: increase .gui.index\nleft arrow/up arrow: decrease .gui.index\nnumber keys: assigns class to .gui.index trace"
  }
]